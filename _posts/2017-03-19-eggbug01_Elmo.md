---
layout: post
title: "[핵알못 엘모의 에그 버그헌팅 여행기 1] 쟈 이제 시작이야! 버그를 향한 여행!"
headline: EggBug01
modified: 2017-03-19
categories: Elmo Howto BugHunt Egg
comments: true
featured: true
---

쟈 이제 시작이야~ 버그를 향한 여행! (삐까츄!) 걱정 따윈 없서~ (없써~~) 핵!타!곤!과!! 함께니까!!!!!!! (삐까!!!삐까!!!)

후... HACKTAGON 내부 팀 HacktiveX (Persu & Elmo & XothSec)의 에그 버그 헌팅 프로젝트를 하는 과정을 글 몇개로 정리해보쟈 함미다☆

언제나 그랬듯 모든 포스트는 레알 내가 기억하기 위해 쓰는 글이니까 별 도움 안될것이라눙 깔깔깔

그럼 여행을 떠나볼까여!
<br>

## Ubuntu & xshell 환경 설정

난 브엠에서 왔다갔다 하기 기차느고 호오옥시나 서버 켜두고 아무때나 내 머신을 사용할 때를 대비하여 xshell을 쓰기로 하여따. 안쓸거면 binwalk만 설치하고 이 파트는 넘기쟈~
<br>

### Binwalk 설치

펌웨어는 binwalk로 까는데
그러려면 binwalk가 있어야겠지
binwalk를 깔자
```
sudo apt-get install binwalk
```

근데 난 시작부터 망스멜각

```
E: Could not get lock /var/lib/dpkg/lock - open( 11 Resource  temporarily unavailable)
E: Unable  to lock  the administration directory (/var/lib/dpkg/), is another process
```
에러남
이런 에러가 나면 아래처럼 해주고
```
sudo rm -rf /var/lib/dpkg/lock
sudo apt-get autoclean $$ apt-get clear cache
```
다시 binwalk를 까는 시도를 해보쟈
<br>

### SSH 설정

우선 우분투에 ssh 깔려있는지 알아보기
```
sudo dpkg -l | grep ssh
```

혹은 ssh listener가 있는지 확인
```
sudo netstat -lntp
```

없으면 설치하쟈
```
sudo apt-get install ssh
```

다시 listener를 확인하면 :::22로 sshd가 동작중인걸 확인가능함

그럼 이제 ubuntu ip를 확인(ifconfig)하고 xshell 에서 평소 하던데로 그 아이피 22번포트에 연결하면 되겠징

```
Last login: Fri Mar 17 08:25:49 2017 from 192.168.26.1
elmo@ubuntu:~$
```
쯀류쯀류~~
<br>

### xshell로 ubuntu에 파일 업/다운로드 전송

로컬에서 브엠으로 파일 마구마구 편하게 옮기려면

```
apt-get install lrzsz
```
설치 후에 다운로드를 할때는
```
sz 파일명
```
업로드할때는
```
xshell 화면으로 파일을 드래그 앤 드롭
```
 해주면 된다~
<br>
<br>

## 펌웨어 까기

### 분석할 바이너리 선정

에그를 깔거시다
에그 제조사 홈페이지의 펌웨어를 다운받고 binwalk를 사용해서 펌웨어를 까자
```
binwalk -e 펌웨어파일
```

그럼 펌웨어 내부 폴더들과 파일들이 까져서 보이게 되는데 겁나 많음
이중에서 뭘 아이다로 켜서 파워 f5를 눌러야하지?

보통
LAN에서는 공유기 설정 페이지를 노리고
WAN은 VPN를 노림

그래서 어떤 바이너리가 웹이랑 통신하나~를 확인하려면
```
grep -rn REQUEST *
```
명령어가 핵꿀인것!

위 명령의 검색결과는 바이너리 파일들인데,
goahead, webs, boa같은 바이너리가 중요함 'ㅅ'
얘네가 결과로 나오면 걔를 이제 아이다로 켜서 집중적으로 보면 됨!

```
elmo@ubuntu:~/_무슨무슨에그펌웨어.enc.extracted/cramfs-root$ grep -rn REQUEST *
Binary file bin/goahead matches
Binary file bin/dhcp6c matches
Binary file bin/tcpdump matches
Binary file bin/ip6tables matches
Binary file bin/strace matches
Binary file bin/updater matches
Binary file bin/dnsmasq matches
Binary file bin/iptables matches
Binary file bin/dhcp6s matches
Binary file bin/curl matches
Binary file bin/smbpasswd matches
Binary file bin/dhcpcd matches
Binary file bin/smbd matches
```
우왕 맨처음에 bin안에 있는 goahead가 보이넹 개굿
<br>
<br>

### 바이너리의 함수와 변수

아이다를 통해서 해당 바이너리를 까고보면 커맨드 인젝션 버그가 갱장히 많을 확률이 높음 쀼쀼
라우터에서 터질만한건 대부분 커맨드 인젝션 또는 BOF
(그런데 난 핵알못이니까 그 많다는 커맨드 인젝션이나 BOF나 뭔들 보지모태 흑흑)

CI 장점
* 익스가 젤 편함
* 찾기도 쉬움
* sprintf와 system 함수만 찾으면 됨
<br>

#### 함수

form어짜구 저짜구로 이루어져있는 함수 위주로 보는걸 추천
사용자에게 인자를 전달받는 함수일 가능성이 높기 때문!
> formWsc
formSaveConfig 등등

하지만 form어짜구로 되어있는 바이너리는 strip이 안되어 있는류
strip이 되어 있으면 sub_xxxx 밖에 엄따 ㅠㅠ

system()함수를 찾아 x를 누르면 그 함수를 사용하는 콜러 함수들의 목록을 볼 수 있음 (xref)
<br>

#### 변수
```
a0, a1, a2, a3
$a0 : 함수의 첫번째 인자 (변수의 주소)
$a1 : sprintf 서식문자 + 문자열    
      예) echo %s > /var/wps_start_pin
$a2 : %s에 들어갈만한 문자열
* 어떤 문자열을 가지고 있는지는 모름
  스택의 어떤 저장되어 있는 값
  또는 사용자 입력값
  -> 사용자 입력값을 받으면 CI나 BOF가 가능할지도 모름!!
```

사용자 입력을 받은 걸 시스템함수로 집어 넣는 순서는 다음과 같당
1)사용자로부터 입력을 받은 후에
2)sprintf함수로 변수에 씀
3)system함수에 그 변수 넣고 실행
<br>
<br>

### 아이다로 취약한 벡터 찾기

#### system() 찾기

어떤 함수가 system()를 사용하더라도 사용자가 입력한 값을 바로 system()에 넣어 호출하는 것이 아니라 format으로 보내서 string을 만들고 문자 체크 후에 실행할 수 있음

따라서 해당 바이너리에서 system()이 사용되기 까지의 구조와 흐름을 파악해야함!

"ping "이라는 string을 검색해서 뒤로 뒤로 거슬러 올라가다보면 시작점 같은 룩희룩희 늑힘적인 늑힘늑힘인 어떤 함수를 찾아보는 방법이 있땅
> "ping은 system 함수를 쓸거란 예상..? 어느정도의 감...?" - 2017년 3월 XothSec

```
.text:0003AF70 sub_3AEAC                 LDR             R0, =aPingC5SSMvSS ; "(ping -c 5 %s > %s; mv %s %s) &"
```
"ping " (ping+띄어쓰기 하나) 검색 결과 3AEAC에서 ping이라는 문자열이 사용되었으며

```
int __fastcall sub_3AEAC(int a1, int a2, int a3)
{
  char *v3; // r3@1
  int v5; // [sp+Ch] [bp-20Ch]@1
  char *s; // [sp+210h] [bp-8h]@1

  v5 = a1;
  s = (char *)a3;
  sub_327DC((int)"rm -f %s %s", (int)"/tmp/ping_result.txt", (int)"/tmp/ping_running.txt", a3);
  v3 = strchr(s, 59);
  if ( v3
    || (v3 = strchr(s, 124)) != 0
    || (v3 = strchr(s, 62)) != 0
    || (v3 = strchr(s, 60)) != 0
    || (v3 = strchr(s, 38)) != 0 )
  {
    sub_327DC((int)"echo \"%s\" > %s", (int)"곸씠 섎せ섏뿀듬땲", (int)"/tmp/ping_result.txt", (int)v3);
  }
  else
  {
    sub_327DC(
      (int)"(ping -c 5 %s > %s; mv %s %s) &",
      (int)s,
      (int)"/tmp/ping_running.txt",
      (int)"/tmp/ping_running.txt");
  }
  sub_23434(v5, "HTTP/1.1 200 OK\nContent-type: text/plain\nPragma: no-cache\nCache-Control: no-cache\n\n");
  sub_23434(v5, "done");
  return sub_238C8(v5, 200);
}
```
그 문자열은 327DC에 보내진당
그 ping 문자열 외에 보면 rm 명령이나 echo 명령도 327DC 함수 인자로 들어가는걸 확인할수 이쑴
<br>

```
int __fastcall sub_327DC(int a1, int a2, int a3, int a4)
{
  char *command; // [sp+0h] [bp-10h]@1
  int *v6; // [sp+4h] [bp-Ch]@1
  int v7; // [sp+8h] [bp-8h]@1
  int varg_r0; // [sp+14h] [bp+4h]@1
  int varg_r1; // [sp+18h] [bp+8h]@1
  int varg_r2; // [sp+1Ch] [bp+Ch]@1
  int varg_r3; // [sp+20h] [bp+10h]@1

  varg_r0 = a1;
  varg_r1 = a2;
  varg_r2 = a3;
  varg_r3 = a4;
  command = 0;
  v7 = 0;
  v6 = &varg_r1;
  if ( sub_12E7C(&command, 4096, a1, (int)&varg_r1) > 4095 )
    sub_1881C(0, "doSystem: lost data, buffer overflow\n");
  if ( command )
  {
    v7 = system(command);
    sub_ABC4(command);
  }
  return v7;
}
```
system("ping ..")을 찾고 싶었지만 이게 아니라 327DC("ping ..")을 찾은 격이고 이제 여기서 진짜 system()까지의 여정을 살펴보자

> system 함수는 바로 호출하면 위험하니깐 my_system라는걸 만들어서 my_system("ping") 으로 코딩하기로 이 에그 개발자들끼리 약속을 했다고 치자,
그러면 리버싱 하는 입장에서 어떤 system() 명령어를 사용하는지 보고싶을땐 system 함수를 xref하는게 아니라 my_system 함수를 xref해야지 어떤 명령어를 사용하는지 알 수 있는 것이다!!
my_system을 xref 해서 my_system("ping %s", ipaddr)이란걸 찾으면,
"아하! ipaddr은 내가 입력을 줄 수 있는 인자인데 이걸 ping을 쏘는 system 명령이 실행되겠구나 여기서 Command Injection이 되겠구낭!"하고 생각하면 댐!!!
이런 구조에서 system()은 아무리 xref해봤자 my_system 함수에서 쓰임. 끗. 빠염☆이 되어버린당..!

327DC의 system()함수에는 command라는 char*이 들어가는데, command는 327DC에서 어떻게 만들어 지는 걸까?

뭣도 모르지만 Persu와 XothSec 님덜의 명언에 따라 327DC 함수란 인자로 받은 문자열들을 sprintf로 합치고 black character check 하고 system 함수를 호출한다고 감을 믿고 가정해보면, sub_12E7C는 sprintf 같은 역할을 하는것으로 추정할 수 있다!

sub_327DC을 xref해보면,
sub_327DC("rm /var/idle_mode_ping.conf");
이렇게 그냥 상수 문자열도 있고,
sub_327DC("ucm_if wdmcmd \"cfg idle start_TO %s\"& ", v6);
이렇게 %s를 쓰는 것도 있고,
sub_327DC("ucm_if wdmcmd \"sfs %s %s\"", v3, result);
이렇게 %s를 두번 쓰는 것도 있는데,
이런 인자들을 327DC에서는 sub_12E7C(&command, 4096, a1, (int)&varg_r1) 이렇게 보낸 뒤에 system(command) 하기 때문! 뜌둔!

그전에 327DC에 ping을 넣었던 3AEAC를 다시 살펴봐보쟈

```
int __fastcall sub_3AEAC(int a1, int a2, int a3)
{
  char *v3; // r3@1
  int v5; // [sp+Ch] [bp-20Ch]@1
  char *s; // [sp+210h] [bp-8h]@1

  v5 = a1;
  s = (char *)a3;
  sub_327DC((int)"rm -f %s %s", (int)"/tmp/ping_result.txt", (int)"/tmp/ping_running.txt", a3);
  v3 = strchr(s, 59);
  if ( v3
    || (v3 = strchr(s, 124)) != 0
    || (v3 = strchr(s, 62)) != 0
    || (v3 = strchr(s, 60)) != 0
    || (v3 = strchr(s, 38)) != 0 )
  {
    sub_327DC((int)"echo \"%s\" > %s", (int)"곸씠 섎せ섏뿀듬땲", (int)"/tmp/ping_result.txt", (int)v3);
  }
  else
  {
    sub_327DC(
      (int)"(ping -c 5 %s > %s; mv %s %s) &",
      (int)s,
      (int)"/tmp/ping_running.txt",
      (int)"/tmp/ping_running.txt");
  }
  sub_23434(v5, "HTTP/1.1 200 OK\nContent-type: text/plain\nPragma: no-cache\nCache-Control: no-cache\n\n");
  sub_23434(v5, "done");
  return sub_238C8(v5, 200);
}
```
ping을 327DC에 주면서 동시에 s에 124, 62, 60, 38이 들어가는지 확인한다..? 디게 아스키같다 그춍
저 숫자들을 클릭하고 r을 누르면 아스키로 변환해쥼

```
v3 = strchr(s, ';');
  if ( v3
    || (v3 = strchr(s, '|')) != 0
    || (v3 = strchr(s, '>')) != 0
    || (v3 = strchr(s, '<')) != 0
    || (v3 = strchr(s, '&')) != 0 )
  {
```
오호? 인젝션에 자주 쓰이는 문자들을 거르려고 하는걸 보니 쟤들만 우회하면 s로 command injection이 가능 하려나~~?

>cat filename을 사용할때
 cat a; cat .passwd하면 .passwd가 출력됨! ;이 왜 command injection을 막으려는 시도인지 참고

s는 어디서 쓰이지?
```
sub_327DC(
  (int)"(ping -c 5 %s > %s; mv %s %s) &",
  (int)s,
  (int)"/tmp/ping_running.txt",
  (int)"/tmp/ping_running.txt");
```
에서 s가 쓰이는군!

그런데 \$라는 환경변수 문자열은 검사하지 않는것 같은데..? \$ 환경변수를 통하면 Injection이 되지 않을깡

이제 sprintf 역할을 할것으로 추정했던 12E7C에서 인자들을 모아 command를 만들면서 호오오옥시나 $를 거기서 거르는지, black character check (블랙리스트)가 제대로 적용되어 있는지 확인해볼 필요가 있당
<br>

#### sprintf() 찾기

```
int __fastcall sub_12E7C(_DWORD *a1, int a2, int a3, int a4)
{
  *a1 = 0;
  return sub_12ED0((const char **)a1, a2, (char *)a3, (int *)a4, 0);
}
```
127EC는 다시 12ED0으로 인자들을 보내버림 'ㅅ'
그렇다면 12ED0을 봐야딩

```
int __fastcall sub_12ED0(const char **a1, int a2, char *a3, int *a4, signed int a5)
{
  int *v5; // r3@27
  int *v6; // r3@34
  signed int v7; // r3@41
  int *v8; // r3@47
  int *v9; // r3@48
  int *v10; // r3@57
  등등 변수 많음

...

등등등 샬라샬라

...

  while ( 1 )
  {
    v40 = *v21++;
    if ( !v40 )
      break;
    if ( v40 != '%' || (v40 = *v21, ++v21, v40 == '%') ) //특수문자를 체크 하는군뇨
    {
      sub_13A28(&s, v40);
    }
    else
    {
      v39 = 0;
      v38 = 0;
      v37 = -1;
      while ( v40 )
      {
        switch ( v40 )
        {
          case '-': //파
            v39 |= 1u;
            break;
          case '+': //워
            v39 |= 2u;
            break;
          case ' ': //특
            v39 |= 4u;
            break;
          case '#': //문
            v39 |= 8u;
            break;
          default:
            if ( v40 != 48 )
              goto LABEL_26;
            v39 |= 0x10u;
            break;
        }
        v40 = *v21++;
      }
LABEL_26:
      if ( v40 == '*' )
      {

...

샬라샬라

...

      if ( v40 == 'h' || v40 == 'l' ) //h l
      {
        if ( v40 == 'h' )
          v7 = 32;
        else
          v7 = 64;
        v39 |= v7;
        v40 = *v21++;
      }
      if ( v40 != 'd' && v40 != 'i' ) //d i
      {
        if ( v40 != 'o' && v40 != 'u' && v40 != 'x' && v40 != 'X' ) //o u x X
        {
          if ( v40 == 'c' ) //c
          {
            v12 = v20;
            ++v20;
            v34 = *v12;
            sub_13A28(&s, v34);
          }
          else if ( v40 != 's' && v40 != 'S' ) //s S
          {
            if ( v40 == 'p' ) //p
            {
              v14 = v20;
              ++v20;
              v33 = *v14;
              sub_13CE8(&s, v33, 16, 0);
            }
            else if ( v40 == 'n' ) //n
            {
              if ( v39 & 0x20 )
              {
                v15 = v20;
                ++v20;
                v32 = (_WORD *)*v15;
                *v32 = v27;
              }
...

샬라리샬라 얄라리얄랴셩

...
```
대충보니 %로 if문을 시작하고 특문 몇개 (\$는 확인 안함)와 h, o, n, x, X, d, s 막 이런 문자가 있는지 체크를한다..! %h, %l, %d, %i, %o, %u, %x, %X, %c, %s, %S는 포맷스트링 문자들! 그러므로 얘는 sprintf 함수가 맞는것 같으당 예에에
그리고 아무리 봐도 \$는 없는것 같으당 예에에에

* 대충 함수가 뭐하는지 알았으니까 이제까지 찾았던것들 이름을 바꿔두쟈
sub_327DC위에서 n을 눌러 my_system
sub_12E7C위에서 n을 눌러 my_sprintf_call
sub_12ED0위에서 n을 눌러 my_sprintf로 이름을 대충 알아먹게 바꿔쥼

이제 이 my_sprintf함수를 어떻게 호출하고 인자를 넣고 넘어오는지 알아야 \$표시를 넣고 공격이 가능하게 된다

그런데 3AEAC를 xref 해보면 딱한군데,
```
int sub_3AAF4()
{
  sub_A508("getSelectDMZEnable", sub_3F888);
  sub_A508("getSelectPortForwardEnable", sub_3AFD0);
  sub_A508("getCountPortForwardRules", sub_3C838);
  sub_A508("getTablePortForwardRules", sub_3CBD8);
  sub_A508("getCountIPPortFilterRules", sub_3C960);
  sub_A508("getTableIPPortFilterRules", sub_3D04C);
  sub_A508("getSelectIPPortFilterEnable", sub_3B06C);
  sub_A508("getSelectDirectionFirewallPolicy", sub_3C68C);
  sub_A508("getSelectDefaultFirewallPolicy", sub_3C728);
  sub_A508("getCountURLRules", sub_3C8CC);
  sub_A508("getTableURLFilters", sub_3CA24);
  sub_A508("getCfgSelectFirewall", sub_3F924);
  sub_A508("getArrayIPPortFilterRules", sub_3D530);
  sub_A508("getArrayPortForwardRules", sub_3D60C);
  sub_A508("getArrayURLFilterRules", sub_3D70C);
  sub_A508("getSessionKey", sub_3FB30);
  sub_118A4((int)"DMZ", (int)sub_3ED58);
  sub_118A4((int)"DMZ_init", (int)sub_3EECC);
  sub_118A4((int)"portForward", (int)sub_3E62C);
  sub_118A4((int)"portForwardDelete", (int)sub_3DC48);
  sub_118A4((int)"ipportFilter", (int)sub_3E20C);
  sub_118A4((int)"ipportFilterDelete", (int)sub_3D878);
  sub_118A4((int)"BasicSettings", (int)sub_3EBE8);
  sub_118A4((int)"websURLFilterDelete", (int)sub_3F524);
  sub_118A4((int)"websURLFilter", (int)sub_3F740);
  sub_118A4((int)"websSysFirewall", (int)sub_3EFBC);
  sub_118A4((int)"getStringPingResult", (int)sub_3AD6C);
  sub_118A4((int)"websPingTest", (int)sub_3AEAC);
  sub_118A4((int)"websSysFirewall_eng", (int)sub_3F204);
  sub_118A4((int)"set_tcp_mss", (int)sub_3D80C);
  return sub_A508("checkIfUnderBridgeModeASP", sub_3C7C4);
}
```
우왕 3AAF4에서 뭔가 많이 호출한다
```
int sub_3AAF4()
{
  ...
  sub_118A4("websPingTest", sub_3AEAC);
  ...
}
```
지금 알아보는건 3AEAC에 대한거니까 찾아보면, 118A4의 인자로 부른당

읭 함수 인자로 함수를..?
A("pagename", B); 같은 형식이면
A 내부는
```
void A(char* pn, void* FP)
{
  if(strcpy(pn, "pagename")==0)
    FP(1,2,3) 또는 FP(a1, a2, parameter)
}
```
뭐 이런식의 구조일 것으로 감을 잡아보자
... 난 감이 엄써.. 고생.. 쥬륵...

그럼 이제 A의 역할을 하는것 같은 sub_118A4를 분석을 해야함!

* sub_118A4 -> my_A로 이름을 바꿈!

계속 거슬러 올라가서 어느 웹 페이지 부분에서 어떻게 인자를 주는지 확인하고 거기에 공격을 때리면 뜌뜡

근데 아직 my_A 어떻게 분석해야할지 모르게따..

webGetVar 함수도 찾아야하는데...
<br>

#### webGetVar 찾기

webGetVar : url 파라미터에서 ?id=admin 같은 url이 있을때 webGetVar("id")하면 admin을 반환해주는 함수

인데 얘를 어또케 찾는건지 1도 모르게따..
모르는것 투성이...

\~24시간후...~
<br>

XothSec은 webGetVar를 sub_22B8C로 가정했다고 한다 'ㅅ'
왜죵...?
webGetVar가 언젠간 찾아지겠지!
<br>
<br>

### 에그 관리자페이지로 취약한 벡터 찾기 (이지만 결국 아이다임 아이다짱)

에그를 연결하면 관리 페이지를 볼 수 이따
보통 배터리 판떼기 떼면 ssid와 key를 알려주고, 사용설명서를 보면 관리자 페이지 접속 방법 알랴줌!
땡땡에그의 경우 192.168.1.1 접속하고 id에 user, pw에 key를 적으니까 관리자 페이지가 뜸 뜌듕

페이지를 둘러보면 해당 에그가 제공하는 기능 이모저모를 볼 수 있는데... 거기서 사용자 입력을 받는 기능을 확인해보쟈

<img src="{{ site.url }}/images/elmo/eggbug01/01_portforward.png" style="float: block; margin: auto;">

우왕 포트포워딩이 요기잉네

아이다에서 "forward"를 검색하자 다시 위에서 봤던 my_A가 나오넹
```
int sub_3AAF4()
{
  ...
  my_A((int)"portForward", (int)sub_3E62C);
  my_A((int)"portForwardDelete", (int)sub_3DC48);
  ...
}
```
<br>

#### portForwardDelete

```
char *__fastcall sub_3DC48(int a1)
{
  char *result; // r0@1
  const char *v2; // r0@2
  bool v3; // r3@5
  size_t v4; // r0@11
  int v5; // r1@25
  int v6; // r2@25
  int v7; // r1@27
  int v8; // r2@27
  int v10; // r2@29
  size_t v11; // r0@31
  int v12; // [sp+8h] [bp-184Ch]@1
  int v13; // [sp+Ch] [bp-1848h]@11
  int v14; // [sp+80Ch] [bp-1048h]@8
  등등 얼랏 오브 변수

  v12 = a1;
  memset(&v15, 0, 0x800u);
  result = (char *)sub_4EC10("PortForwardRules");
  src = result;
  if ( result )
  {
    strncpy((char *)&v16, src, 0x800u);
    v2 = (const char *)sub_22B8C(v12, (int)"submit_type", (char *)&unk_7B198);
    if ( !strcmp(v2, "act") )
    {
      v25 = strtok((char *)&v16, "~");
      v23 = 0;
      while ( v25 )
      {
        v24 = v25;
        v22 = 0;
        while ( *v24 )
        {
          v3 = *v24++ == 44;
          if ( v3 )
            ++v22;
        }
        sprintf((char *)&v14, "delRule%d", v23);
        s1 = (char *)sub_22B8C(v12, (int)&v14, (char *)&unk_7B198);
        sprintf((char *)&v14, "actRule%d", v23);
        v19 = (char *)sub_22B8C(v12, (int)&v14, (char *)&unk_7B198);
        if ( s1 && !strcmp(s1, "1") && v22 == 5 )
        {
          strcpy((char *)&v13, v25);
          v4 = strlen((const char *)&v13);
          strcpy((char *)&v13 + v4 - 1, v19);
        }

        샬라샬라

  return result;
}
```
위에서부터 sub_22B8C를 차분히 xref해본 결과 sub_22B8C를 webGetVar로 가정했다고한당
sub_22B8C(v12, "submit_type")=="act"인지 아닌지 확인하는 구문이 있으니까 혹시 sub_22B8C가 웹에서 파라미터로 준거 파싱하는건가? 라는 의문을 가지고 xref를 해서 아 이거 맞는거 같은데?하면 my_webGetVar로 이름을 붙여두고 다른것도 더 분석하다가 아니면 말고 맞으면 좋고!

* sub_22B8C -> my_webGetVar 이름 바꿈
<br>

my_webGetVar를 xref하고 맨 위에있는 함수 sub_1D564를 살펴보면
```
int __fastcall sub_1D564(int a1)
{
  int v1; // ST14_4@1
  int v2; // ST10_4@8
  int v4; // [sp+Ch] [bp-2Ch]@1
  char *v5; // [sp+18h] [bp-20h]@1
  int v6; // [sp+1Ch] [bp-1Ch]@1
  char *s2; // [sp+20h] [bp-18h]@1
  char *s1; // [sp+24h] [bp-14h]@1
  int v9; // [sp+28h] [bp-10h]@1

  v4 = a1;
  v9 = my_webGetVar(a1, (int)"user", (char *)&unk_6F408);
  s1 = (char *)my_webGetVar(v4, (int)"password", (char *)&unk_6F408);
  s2 = (char *)my_webGetVar(v4, (int)"passconf", (char *)&unk_6F408);
  v6 = my_webGetVar(v4, (int)"group", (char *)&unk_6F408);
  v5 = (char *)my_webGetVar(v4, (int)"enabled", (char *)&unk_6F408);
  v1 = my_webGetVar(v4, (int)"ok", (char *)&unk_6F408);
  sub_1199C(v4);
  sub_1E7C8(v4);
  if ( sub_245C8(v1, "ok") )
  {
    ((void (__fastcall *)(_DWORD, _DWORD))sub_23434)(v4, "Add User Cancelled");
  }
  else if ( !strcmp(s1, s2) )
  {
    if ( v5 && *v5 )
      strcmp(v5, "on");
    v2 = sub_1B774(v9, s1, v6, 0);
    if ( v2 )
      sub_23434(v4, "Unable to add user, \"%s\".  %s");
    else
      sub_23434(v4, "User, \"%s\" was successfully added.", v9);
  }
  else
  {
    ((void (__fastcall *)(_DWORD, _DWORD))sub_23434)(v4, "Confirmation Password did not match.");
  }
  sub_1E7F0(v4);
  sub_11D44(v4);
  return sub_238C8(v4, 200);
}
```
password랑 passconf랑 enabled같은 걸 어떤 값과 함께 my_webGetVar 함?

그럼 sub_1D564를 xref로 쫓아가보쟈!

뀨...? 이상한데 .text 영역으로 떨어짐... 위에 종료도 이상하고 ㅇㅅㅇ..
./text로 떨어진 곳 윗쪽 어떤 함수가 종료된곳 바로 밑 첫줄에서 우클릭 - Create Function 하면 아이다가 다시 제대로 분석해서 함수로 만들어줌
```
signed int sub_1D440()
{
  sub_A508("MakeGroupList", sub_1DFA4);
  sub_A508("MakeUserList", sub_1DA54);
  sub_A508("MakeAccessLimitList", sub_1E388);
  sub_A508("MakeAccessMethodList", sub_1E454);
  sub_A508("MakePrivilegeList", sub_1E544);
  my_A((int)"AddUser", (int)sub_1D564);
  my_A((int)"DeleteUser", (int)sub_1D7C0);
  my_A((int)"DisplayUser", (int)sub_1D90C);
  my_A((int)"AddGroup", (int)sub_1DB20);
  my_A((int)"DeleteGroup", (int)sub_1DE28);
  my_A((int)"AddAccessLimit", (int)sub_1E084);
  my_A((int)"DeleteAccessLimit", (int)sub_1E29C);
  my_A((int)"SaveUserManagement", (int)sub_1E630);
  return my_A((int)"LoadUserManagement", (int)sub_1E6FC);
}
```
꾸아아아아앙 마니 봤던 my_A가 요기에도 있따!!!!
여기서 사용될때도 인자가 두개인데 뒤에꺼는 함수고 앞에꺼는 문자열!!! 그것도 뭔가 '기능'을 나타내는 문자열!!!! sub_1D564 앞에는 "AddUser"래!!!!
웹페이지에서 저 기능을 쓰려고 하면 저 함수를 호출할것만같은 느낌이 온당 온다아앙!!! 'ㅁ'

my_A xref 더 해보면
```
int sub_49180()
{
  int v0; // r0@1

  my_A((int)"pwoff", (int)sub_44294);
  my_A((int)"deep_sleep", (int)sub_4476C);
  my_A((int)"deep_sleep_from_mobile", (int)sub_446FC);
  my_A((int)"setSysAdm", (int)sub_3FB74);
  my_A((int)"NTP", (int)sub_3FECC);
  my_A((int)"CTS", (int)sub_3FF88);
```
이렇게 계속 쓰인당

<img src="{{ site.url }}/images/elmo/eggbug01/02_setSysAdm.png" style="float: block; margin: auto;">
예? 선생님? action="/goform/setSysAdm"이여? setSysAdm 말씀하시는 검미까?
호에에에에에

my_A((int)"setSysAdm", (int)sub_3FB74);
호에에에에에에에

'3' 쵸큼 기부니 조아져따

이로써 sub_3FB74는 setSysAdm이 요청되면 실행되는 함수인걸로 분석이 되어꼬
my_A가 정확히 뭔지는 몰라도 sub_3FB74가 그거슬 통해 어떻게 호출되는지 알게되어따
my_A는 webpage에서 어떤 action 호출 되면 그 이름의 function을 실행함!
* my_A -> webpage_function으로 이름 바꿈

이제 webpage_function의 두번째 인자를 위주로 보면 우리가 호출할 수 있는 함수들을 쉽게 찾을 수 있게 됨!
sub_446FC이 뭔지는 모르겠지만 일단 웹페이지에서 "/goform/deep_sleep_from_mobile"로 작동 될 것 같당!
뜔류뜔류~

움 그래서 아까 찾아놨던 ping은 어디서 하는거지 궁금해져서 요소검사에서 ping이란 문자열을 열심히 찾아보았지만 없었다고 한다... 쀼.. 시무룩.. 숨겨진 기능..? 숨겨진 페이지...? 일단 제낌 ㅃㅃ
<br>

그럼 다시 돌아돌아 portForwardDelete를 처리하는 sub_3DC48을 보쟈 ㅋㅋㅋㅋㅋㅋㅋㅋ아 정신엄써

```
char *__fastcall sub_3DC48(int a1)
{
  size_t v4; // r0@11
  int v12; // [sp+8h] [bp-184Ch]@1
  int v13; // [sp+Ch] [bp-1848h]@11
  int v14; // [sp+80Ch] [bp-1048h]@8
  int v15; // [sp+82Ch] [bp-1028h]@1
  int v16; // [sp+102Ch] [bp-828h]@2
  char *s; // [sp+182Ch] [bp-28h]@23
  char *v18; // [sp+1830h] [bp-24h]@23
  char *v19; // [sp+1834h] [bp-20h]@8
  등등 얼랏 오브 변수

  v12 = a1;
  memset(&v15, 0, 0x800u);
  result = (char *)sub_4EC10("PortForwardRules");
  src = result;
  if ( result )
  {
    strncpy((char *)&v16, src, 0x800u);

  샬라샬라

        v19 = (char *)my_webGetVar(v12, (int)&v14, (char *)&unk_7B198);
        if ( s1 && !strcmp(s1, "1") && v22 == 5 )
        {
          strcpy((char *)&v13, v25);
          v4 = strlen((const char *)&v13);
          strcpy((char *)&v13 + v4 - 1, v19);
        }

  샬라샬라
}
```

webGetVar로 받아온 v19를 strcpy로 &v13 + v4 - 1 로 넣는 것을 알 수 있음!
근데 어맛! v13이 stack영역이넹..?
물논 우리 핵타곤의 갓님들은 heap, bss 오버플로우같은걸 슈슈슛 하시지만.. 난 일단 stack bof를 통해서 ret를 덮는걸 목표로 하기 때무네!.. 사용자 입력값이 스택에 들어가는것이 매우 중요 희희
<br>

##### v13이 stack영역인지는 어떻게 알았징?
v13은 변수 선언부를 보면 bp-1848h부터 bp-1048h까지의 메모리를 사용하고 있으니까 0x800 바이트나 메모리를 쓴단 말! 만약 bp-1848h이 하나의 변수고 bp-1048h이 하나의 변수면 중간에 0x800 바이트나 버리는것이니까 이는 즉슨 요것들은 배열이라는것..!

또한 strcpy(&13, ~~~)은 bp-1848h (ebp-1848)영역에 어떤 문자열을 copy하는건뎅, 이걸 기이이일게 시키면 ebp + 4까지 덮어 버린다고도 생각할 수 이따! (ebp, esp는 스택 영역 라잌댓? 유노우댓?)

스택을 안쓰는 경우는 어떠하냐면,
```
char *p = malloc(1024);
strcpy(p)
```
이런 형식인데, 이를 아이다로 리버싱할 경우
```
int v19;
v19 = malloc(~~~)
strcpy(v19,~~~)
```
으로 보여짐! 결국 v13이냐 &v13이냐의 차이!

v19는 v13과 다르게 선언될때도 char* 포인터, 값을 받아올때도 v19 = (char*)my_webGetVar(~~~); 포인터인것을 확인할 수 있음!

```
// v13같은 배열  -----------> Stack에 512바이트! stack overflow 할 수 이따!
char buf[512];
strcpy(&buf, "AAAA")

// v19같은 포인터 ----------> Stack에는 4바이트짜리 포인터하나에 Heap 영역 512 바이트 있는것! sof 앙대
char *buf = malloc(512);
strcpy(buf, "AAAA")
```
<br>

##### 왜 포인터로 된것에서는 stack overflow가 앙대는거딩?

strcpy은 메모리 주소를 두개 입력 받아서 앞에 메모리 주소에 뒤에 메모리 주소 문자열을 옮겨주는 개념
이걸 생각해보면 포인터에는 스택 오버플로우를 할 수 엄찌!
포인터 변수 p라는 애의 주소에 strcpy하는게 아니라 p가 가리키고 있는 heap영역 주소에 strcpy하는거니깐!


<br>
<br>
<br>
후우우움
삼일에 걸쳐서 뭘 계속 시작만 마니 한거같고 결론은 없는거 같다 돼써 혼자 뿌듯하면 된거야 흥
이제 이런식으로 버그를 더 찾아보도록 하쟈! 뿌잉!
portForwardDelete에 스택오버플로우나, 숨겨져있는것 같은 ping 코맨드인젝션을 QEMU에 올려서 다시 시도를 해보쟈고 Persu랑 XothSec님덜이 그러셔서 다음 편은 QEMU에 펌웨어 올리기와 버그를 찾기 위한 삽질 여행기를 계속 해보아요~~~ (언제 돌아올지는 모름...)
뿅!
